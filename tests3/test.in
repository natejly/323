echo "### Simple redirection: output redirection"

echo "this is an output file!" > temp
cat temp
printenv ?
rm temp
printenv ?
printenv ?

echo "### Simple redirection: output redirection (append mode)"

echo "this is an output file!" >> temp
printenv ?
echo "this goes there too!" >> temp
printenv ?
cat temp
printenv ?
rm temp
printenv ?

echo "### Simple redirection: input redirection"
echo does any redirection work spongebob?
printenv ?
echo "this is an input file!" > temp
printenv ?
cat -n < temp
printenv ?
rm temp
printenv ?

echo "### Simple redirection: HERE files"
cat -n << BANANA
red
green
blue
BANANA
printenv ?

echo "### Pipelines"

/c/cs323/proj4/tests/exit 0 | /c/cs323/proj4/tests/exit 0 | /c/cs323/proj4/tests/exit 0
printenv ?

/c/cs323/proj4/tests/exit 1 | /c/cs323/proj4/tests/exit 0 | /c/cs323/proj4/tests/exit 0
printenv ?

/c/cs323/proj4/tests/exit 0 | /c/cs323/proj4/tests/exit 1 | /c/cs323/proj4/tests/exit 0
printenv ?

/c/cs323/proj4/tests/exit 0 | /c/cs323/proj4/tests/exit 0 | /c/cs323/proj4/tests/exit 1
printenv ?

/c/cs323/proj4/tests/exit 4 | /c/cs323/proj4/tests/exit 0 | /c/cs323/proj4/tests/exit 1
printenv ?

/c/cs323/proj4/tests/exit 4 | /c/cs323/proj4/tests/exit 0
printenv ?

/c/cs323/proj4/tests/exit 0 | /c/cs323/proj4/tests/exit 4
printenv ?

cd / | pwd
pwd
printenv ?

echo "### Conditionals: and"

/c/cs323/proj4/tests/exit 0 && /c/cs323/proj4/tests/exit 0
printenv ?

/c/cs323/proj4/tests/exit 5 && /c/cs323/proj4/tests/exit 0
printenv ?

/c/cs323/proj4/tests/exit 0 && /c/cs323/proj4/tests/exit 5
printenv ?

/c/cs323/proj4/tests/exit 0 && echo "This should print"
printenv ?

/c/cs323/proj4/tests/exit 1 && echo "This should NOT print"
printenv ?

echo "### Conditionals: or"

/c/cs323/proj4/tests/exit 0 || /c/cs323/proj4/tests/exit 0
printenv ?

/c/cs323/proj4/tests/exit 5 || /c/cs323/proj4/tests/exit 0
printenv ?

/c/cs323/proj4/tests/exit 0 || /c/cs323/proj4/tests/exit 5
printenv ?

/c/cs323/proj4/tests/exit 0 || echo "This should NOT print"
printenv ?

/c/cs323/proj4/tests/exit 1 || echo "This should print"
printenv ?

echo "### Conditionals: mixed"
/c/cs323/proj4/tests/exit 1 && /c/cs323/proj4/tests/exit 0 || echo "print me"
printenv ?

echo "### Environment variables"
FRUIT=APPLE printenv FRUIT
printenv FRUIT
FIRSTNAME=JAY LASTNAME=LIM printenv FIRSTNAME
SHARKS=COOL /c/cs323/proj4/tests/exit 0 | printenv SHARKS
printenv ?

echo "### Subcommands"
/c/cs323/proj4/tests/exit 1 && (/c/cs323/proj4/tests/exit 0 || echo "don't print me")
SHARKS=COOL (/c/cs323/proj4/tests/exit 0 | printenv SHARKS)

echo "### Built-ins"
pushd .
printenv ?
cd
printenv ?
pwd
popd
printenv ?
pwd

cd tests
printenv ?
pwd

cd this_directory_doesnt_exist
printenv ?
pwd

cd too many args | echo hi
printenv ?

pushd
printenv ?

pushd too many args
printenv ?

popd too many args
printenv ?

echo "### SEP_END"

/c/cs323/proj4/tests/exit 42
/c/cs323/proj4/tests/exit 5 ; /c/cs323/proj4/tests/exit 4 ; printenv ?

/c/cs323/proj4/tests/exit 42
/c/cs323/proj4/tests/exit 0 ; /c/cs323/proj4/tests/exit 1 ; /c/cs323/proj4/tests/exit 2
printenv ?

echo "### Redirection of built-ins"
pushd /etc >> built_in_redir.out
popd
echo "That was built-in redirection!" >> built_in_redir.out
cat built_in_redir.out
rm built_in_redir.out

echo "### Backgrounding"
cd /etc &
sleep 1
pwd
printenv ?

sleep 1 &
echo hi
sleep 2
echo bye
printenv ?

sleep 2 | echo hi &
sleep 3
echo apple
printenv ?

sleep 2 && echo hi &
echo banana
sleep 3
echo apple
printenv ?

sleep 2 || echo hi &
echo banana
sleep 3
echo apple
printenv ?

sleep 2 ; echo yo &
sleep 1
printenv ?

echo "### Random edge cases that I and other users on EdStem found"

echo "hello" | echo "there"

this_command_doesnt_exist haha very funny
printenv ?

cat tests/assets/inaccessible_file.txt
printenv ?

echo nickelodeon
echo "nickelodeon" >> tests/assets/inaccessible_file.txt
printenv ?

cat -n < tests/assets/inaccessible_file.txt
printenv ?

/c/cs323/proj4/tests/exit 1
/c/cs323/proj4/tests/exit 5 | printenv ?

( echo vvvvvvvv ; cat ; echo ^^^^^^^^ ) << HERE
uwu
owo
HERE

echo Ananya tests begin!

echo "### Local variables and combinations"
echo "Local variables should work with pipes, and, or, and subcommands"
A=1 B=2 printenv A B | grep 1 && echo "Local A found" || echo "Local A not found"
(c=C3 printenv C; D=4) && printenv D || echo "D should not persist outside subcommand"

echo "### Redirect stdin to HERE document (<<)"
cat <<EOF1
This is the first here document.
EOF1

cat <<EOF2 | grep 'second'
This is the second here document.
EOF2

cat -n <<EOF3
This will list lines from the here document.
EOF3

(echo "Subcommand with HERE document"; cat <<EOF4
Subcommand content
EOF4
) | grep 'Subcommand'

echo "### Redirect stdout to file (>, >>)"
echo "Creating a new file" > newfile.txt
cat newfile.txt
echo "Appending to the file" >> newfile.txt
cat newfile.txt
rm newfile.txt

echo "### Redirect stdout to pipe and check behavior"
echo "Output should be captured by pipe" | grep "Output"
(echo "First command" && false) | grep "First" || echo "Pipe should catch this"

echo "### Multiple commands per line with diverse redirections and subcommands"
echo "Multiple" > multi.txt; cat multi.txt && rm multi.txt | echo "Cleanup" && echo "Done"

echo "### Background commands (&) and checking their completion"
sleep 1 & wait; echo "Background command with wait completed"

echo "### && and || combinations"
false && echo "This should not print" || echo "This should print"
true || echo "This should not print" && echo "This still prints"

echo "### Grouped commands with redirections"
{ echo "Grouped command 1"; echo "Grouped command 2"; } > grouped.txt
cat grouped.txt
rm grouped.txt

echo "### Testing for command termination before the next begins"
sleep 1 && echo "Sleep completed" || echo "Sleep failed"
{ false && echo "This should not run"; } || echo "Group failure detected"

echo "### Testing cd's behavior in various contexts"
cd /tmp && pwd
cd - && pwd
{ cd / && pwd; } > cd_output.txt
cat cd_output.txt
rm cd_output.txt

echo "### Testing pushd/popd alongside cd"
pushd /tmp
popd
cd /
pushd .
popd

echo "### Checking STATUS variable set under different conditions"
false; printenv ?
true; printenv ?
{ false; } && printenv ?

echo "### Checking file descriptor management"
exec 3<> fd_test.txt
echo "File descriptor test" >&3
exec 3>&-
cat fd_test.txt
rm fd_test.txt

echo "### Edge cases that might involve signal handling, zombies, and resource management"
sleep 10 & kill $!
wait $! 2>/dev/null && echo "Zombie process handled" || echo "Zombie process not found"

echo "### Advanced HERE document with variable expansion"
NAME="Bash Tester"
cat <<EOF
Hello, $NAME!
This tests variable expansion within a HERE document.
EOF

echo "### Variable Unset and Null Test"
unset UNSET_VAR
[ -z "$UNSET_VAR" ] && echo "UNSET_VAR is unset or null" || echo "UNSET_VAR has value"
printenv ?

echo "### Read Only Variable Test"
readonly READ_ONLY_VAR="readonly"
READ_ONLY_VAR="changed" 2>/dev/null
printenv READ_ONLY_VAR
printenv ?

echo "### Function Export and Execution in Subshell"
export -f hello_world
(bash -c 'hello_world')
printenv ?

echo "### File Descriptor Leakage Check"
exec 3>&1
exec 4>&2
{ echo "Redirecting STDOUT and STDERR"; } >&3 2>&4
printenv ?

echo "### Arithmetic Expansion and Evaluation"
RESULT=$((1 + 2))
echo "1 + 2 = $RESULT"
[ "$RESULT" -eq 3 ] && printenv ? || printenv ?

echo "### Test for Command Not Found"
command_not_found
printenv ?

echo "### Test for Permission Denied"
chmod -x /tmp/non_executable_script.sh
/tmp/non_executable_script.sh
printenv ?

echo "### Path Environment Variable Test"
OLD_PATH=$PATH
export PATH=""
which ls
printenv ?
export PATH=$OLD_PATH

echo "### Alias Definition and Expansion"
alias ll='ls -l'
alias ll
printenv ?

echo "### Wildcard Expansion in Directory with No Matches"
ls *.notfound 2>/dev/null
printenv ?

echo "### Tilde Expansion for Home Directory"
ls ~/
printenv ?

echo "### Brace Expansion Test"
echo file_{a,b,c}.txt
printenv ?

echo "### Test Exit within Script"
(echo "Before exit"; exit 42; echo "After exit")
printenv ?

echo "### Test Trapping Signals"
trap 'echo "SIGINT trapped."' SIGINT
kill -SIGINT $$
printenv ?

echo "### Negative Test: Writing to a Read-only File System"
mount -o remount,ro /
echo "test" > /readonlytest 2>/dev/null
printenv ?
mount -o remount,rw /

echo "### Job Control Test: Bringing Job to Foreground"
sleep 30 &
fg %1
printenv ?


echo "### pushd/popd: Basic pushd and popd"
pushd /tmp
pwd
popd

echo "### pushd/popd: Nested pushd"
pushd /tmp
pushd /
pwd
popd
pwd
popd

echo "### pushd/popd: Pushd with non-existent directory"
pushd /this_directory_does_not_exist
printenv ?

echo "### pushd/popd: Popd without push"
popd
printenv ?


echo "### Setting STATUS: Command success"
/c/cs323/proj4/tests/exit 0
printenv ?

echo "### Setting STATUS: Command failure"
/c/cs323/proj4/tests/exit 1
printenv ?

echo "### Setting STATUS: Sequential commands with mixed exit statuses"
/c/cs323/proj4/tests/exit 0; /c/cs323/proj4/tests/exit 1
printenv ?

echo "### Setting STATUS: Last command dictates STATUS"
/c/cs323/proj4/tests/exit 3; /c/cs323/proj4/tests/exit 2; /c/cs323/proj4/tests/exit 1
printenv ?

echo "### Errors: Command not found"
command_that_does_not_exist
printenv ?

echo "### Errors: Permission denied on execution"
chmod -x /tmp/non_executable_script.sh
/tmp/non_executable_script.sh 2>/dev/null
printenv ?

echo "### Errors: Write to read-only file"
echo "Test" > /readonly_file.txt 2>/dev/null
printenv ?

echo "### Errors: Execute script without execute permissions"
chmod -x /tmp/script_without_execute_permission.sh
/tmp/script_without_execute_permission.sh 2>/dev/null
printenv ?

echo "### Close file descriptors: Open and close custom fd"
exec 3>/tmp/custom_fd_test
echo "Writing to custom fd" >&3
exec 3>&-
cat /tmp/custom_fd_test
rm /tmp/custom_fd_test

echo "### Close file descriptors: Verify fd is closed"
{ echo "Test"; } >&3 2>/dev/null
printenv ?

echo "### Torture: Do zombies die?"
sleep 5 &
PID=$!
kill -HUP $PID 2>/dev/null
wait $PID 2>/dev/null
printenv ?

echo "### Torture: Status of zombie reported correctly"
sleep 5 &
PID=$!
kill -9 $PID
wait $PID 2>/dev/null
printenv ?

echo "### Torture: All storage reachable?"
df / | awk '/\// {print $(NF-1)}'
printenv ?

# Testing pushd/popd with redirection and checking directory stack integrity
echo "### Advanced pushd/popd Interaction"
pushd / >pushd_dir_stack.txt
printenv ?
pushd /tmp >>pushd_dir_stack.txt
printenv ?
popd >>pushd_dir_stack.txt
printenv ?
popd >>pushd_dir_stack.txt
printenv ?
cat pushd_dir_stack.txt
printenv ?
rm pushd_dir_stack.txt
printenv ?

# Complex manipulation of STATUS with nested commands
echo "### Complex STATUS Manipulation"
(c=C3; /c/cs323/proj4/tests/exit 3; /c/cs323/proj4/tests/exit 0) || /c/cs323/proj4/tests/exit 1
printenv ?

# Advanced error handling with nested redirections and subcommands
echo "### Advanced Error Handling"
{ /c/cs323/proj4/tests/exit 4; echo "This should not print" > /dev/null; } 2>&1 | grep "error" || echo "Handled error in subcommand"
printenv ?

# Testing comprehensive file descriptor management
echo "### Comprehensive FD Management"
exec 3>/tmp/fd_test
echo "FD3" >&3
exec 4>/tmp/fd_test
echo "FD4" >&4
exec 3>&- 4>&-
cat /tmp/fd_test
printenv ?
rm /tmp/fd_test
printenv ?

# Torture test involving file system limits and cleanup
echo "### File System Limits Torture Test"
for i in {1..1000}; do touch "/tmp/test_file_$i"; done
printenv ?
rm /tmp/test_file_*
printenv ?

echo "### Testing local variables with pipes, background, and subcommands"
A="outer" (A="inner" echo "Inner A: $A" | grep inner) & A="later" echo "Outer A: $A"

echo "### Feeding multiple HERE documents into a pipeline and subcommand"
cat <<EOF1 | grep "Document 1" && (cat <<EOF2 | grep "Document 2"; echo "EOF2 Reached")
This is Document 1.
EOF1
This is Document 2.
EOF2
printenv ?

cd hi hi hi < non_existent_file.txt
printenv ?

pushd randomshit
popd
printenv ?

cat non_existing_file.txt
printenv ?

echo Ananya is testing woohooo!
printenv ?

HOME=/home/classes/cs323/class/purushottam.ananya.ap2626/proj4/starter-code cd
printenv HOME

cd
pwd

printenv x

y=17 pushd dummy
printenv y
popd

a=/home/accts/ap2626/cs323/proj4/starter-code/dummy pushd a
printenv ?
printenv a

a=/home/accts/ap2626/cs323/proj4/starter-code/dummy pushd a
printenv a

a="dummy" pushd a
printenv ?
printenv a

a=dummy pushd a
printenv ?
printenv a

a=dummy pushd a
printenv a

# Start in a known directory
cd /tmp

# Use pushd to change directories and check stack
pushd /var
# Should output /var /tmp

# Change directories using cd
cd /etc

# Use popd to go back and check the current directory
popd
# Should return to /tmp, verify with pwd
pwd

cd /tmp
pushd /var
pushd /etc
cd /bin
popd
# Should print /var as current directory
pwd
popd
# Should print /tmp as current directory
pwd

# Assuming /nonexistent does not exist
pushd /nonexistent || echo "pushd failed with status printenv ?"
printenv ?

# Assuming /tmp exists
pushd /tmp && echo "pushd succeeded with status printenv ?"
printenv ?

# Pop from an empty stack
popd || echo "popd failed with status printenv ?"
printenv ?


# Assuming /tmp exists and /nonexistent does not
cd /tmp && echo "cd succeeded with status printenv ?"
printenv ?
cd /nonexistent || echo "cd failed with status printenv ?"
printenv ?

# Redirecting output of cd command
cd /tmp > cd_output.txt
# Check if cd_output.txt is empty since cd usually has no output
[ -s cd_output.txt ] && echo "File is not empty" || echo "File is empty"
cat cd_output.txt

echo "/etc" | (cd $(cat) && pwd)
# After running, check if current directory changed
pwd

# Write a directory to a file
echo "/var" > dir.txt
# Use input redirection with cd
cd < dir.txt
# Check current directory
pwd

mkdir deletesoon
cd deletesoon

pushd .

cd ..
pwd
rm -r deletesoon

echo Popping and printing the error code spongebob

popd 
printenv ?

sleep 20

cd /tmp && printenv ? 
cd /nonexistent || printenv ?

echo hi && chdhfehu 
printenv ?

echo hi || eruurefh 
printenv ?

failureeee && echo hi 
printenv ?

failure && nfireifer 
printenv ?

failureeee || echo hi 
printenv ?

failure || nfireifer 
printenv ?

sleep 10
echo backgrounded shit should catch up?

# Create a temporary file for input redirection
echo "Input for redirection" > input.txt

# Create a temporary file to check if file descriptors are left open
exec 3>fd_check.txt

# Execute multiple commands with redirections
# Redirect stdin from input.txt, stdout to output.txt, and append stdout to append.txt
cat < input.txt > output.txt && echo "Appending this line" >> append.txt

# Check open file descriptors for the current shell process
# Replace $$ with the specific process ID if you want to check a different process
lsof -p $$ | grep -E "output.txt|append.txt|input.txt|fd_check.txt" > fd_check.txt

# Output the results
echo "Checking if file descriptors are closed properly..."
cat fd_check.txt

# Cleanup temporary files
rm input.txt output.txt append.txt fd_check.txt

# Close file descriptor 3 explicitly
exec 3>&-

sleep 10
echo backgrounded shit should catch up part 2 lol?

# Create a temporary file to check if file descriptors are left open
exec 3>fd_check_complex.txt

# Execute commands combining pipes, subcommands, sequences, and HERE documents
echo "HERE document input" > here_doc_input.txt
(cat < here_doc_input.txt | tr 'a-z' 'A-Z'; echo "Sequence command") > pipe_and_sequence_output.txt
echo "Subcommand execution" $(echo "inside subcommand" > subcommand_output.txt)
(cat << EOF
This is a HERE document.
It should be transformed to uppercase.
EOF
) | tr 'a-z' 'A-Z' > here_document_output.txt

# Check open file descriptors for the current shell process
# Replace $$ with the specific process ID if you want to check a different process
lsof -p $$ | grep -E "fd_check_complex.txt|pipe_and_sequence_output.txt|subcommand_output.txt|here_document_output.txt" > fd_check_complex.txt

# Output the results
echo "Checking if file descriptors are closed properly for complex operations..."
cat fd_check_complex.txt

# Cleanup temporary files
rm here_doc_input.txt pipe_and_sequence_output.txt subcommand_output.txt here_document_output.txt fd_check_complex.txt

# Close file descriptor 3 explicitly
exec 3>&-

HOME=/home/accts/ap2626/cs323/proj4/starter-code/dummy cd
pwd
cd
pwd

echo goodbye ananya's friends!